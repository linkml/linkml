import os
from typing import Union, TextIO, Dict, List, Tuple

import click
import logging

from sqlalchemy import *
from sqlalchemy import *
from linkml_runtime.linkml_model.meta import ClassDefinition, SlotDefinition, SchemaDefinition, ClassDefinitionName, SlotDefinitionName
from linkml_runtime.linkml_model.types import NCName, URIorCURIE
from linkml_runtime.utils.formatutils import underscore, camelcase
from linkml.utils.generator import Generator, shared_arguments

TABLENAME = str
COLNAME = str
SQL_STR = str

RANGEMAP = {
    'str': Text(),
    'NCName': Text(),
    'URIorCURIE': Text(),
    'int': Integer(),
    'double': Float(),
    'float': Float(),
    'Bool': Boolean(),
    'URI': Text()
}

def _quote(s: str) -> str:
    s = s.replace("'", "\\'")
    return f"'{s}'"



class SQLDDLGenerator(Generator):
    """
    A `Generator` for creating SQL DDL
    TODO: allow configuration between camelcase and snake case for tanle names

    """
    generatorname = os.path.basename(__file__)
    generatorversion = "0.1.1"
    valid_formats = ['proto']
    visit_all_class_slots: bool = True
    use_inherits: bool = False  ## postgresql supports inheritance
    dialect: str
    inject_primary_keys: bool = True
    sqla_python_lines: List[str] = []

    # we maintain our own structure before feeding to sqlalchemy
    # https://stackoverflow.com/questions/52045695/sqlalchemy-remove-column-from-table-definition
    columns: Dict[TABLENAME, Dict[COLNAME, Column]] = {}

    table_to_class: Dict[TABLENAME, ClassDefinition] = {}
    table_columns_to_slot: Dict[Tuple[TABLENAME, COLNAME], SlotDefinition] = {}

    def __init__(self, schema: Union[str, TextIO, SchemaDefinition], dialect='sqlite',
                 use_foreign_keys = True,
                 **kwargs) -> None:
        super().__init__(schema, **kwargs)
        self.relative_slot_num = 0
        self.dialect = dialect
        self.use_foreign_keys = use_foreign_keys
        self.sqla_python_lines = [
            'from sqlalchemy import Column, Index, Table, Text',
            'from sqlalchemy.sql.sqltypes import NullType',
            'from sqlalchemy.ext.declarative import declarative_base',
            '',
            'Base = declarative_base()',
            'metadata = Base.metadata']

    def to_sqla_python(self) -> str:
        return "\n".join(self.sqla_python_lines)

    def _is_hidden(self, cls: ClassDefinition) -> bool:
        if cls.mixin or cls.abstract or not cls.slots:
            return False

    def _cls_name(self, cn: ClassDefinitionName) -> str:
        """
        https://stackoverflow.com/questions/1881123/table-naming-underscore-vs-camelcase-namespaces-singular-vs-plural
        """
        return underscore(cn)

    def _slot_name(self, sn: SlotDefinitionName) -> str:
        """
        use underscore by default
        """
        return underscore(sn)

    def end_schema(self, **kwargs) -> None:
        engine = create_mock_engine(
            f'{self.dialect}://./MyDb',
            strategy='mock',
            executor= lambda sql, *multiparams, **params: print(f'{str(sql).rstrip()};'))
        schema_metadata = MetaData()
        for t,colmap in self.columns.items():
            cls = self.table_to_class[t]
            cols = colmap.values()
            if len(cols) > 0:
                tbl = Table(t, schema_metadata, *cols)
                if cls.description:
                    tbl.comment = cls.description
                else:
                    tbl.comment = f"Autogenerated from class: {cls.name}"
                sqla_lines = ['',
                    f'class {camelcase(t)}(Base):']
                cls = self.table_to_class[t]
                desc = cls.description
                if desc is not None and desc != '':
                    sqla_lines += [
                        '    """',
                        f'    {desc}',
                        '    """'
                    ]
                sqla_lines.append(
                    f"    __tablename__ = '{t}'")
                pks = [col for col in cols if col.primary_key]
                for col in cols:
                    args = ['Text']
                    if len(pks) == 0 or col.primary_key:
                        args.append('primary_key=True')
                    argstr = ", ".join(args)
                    line = f'    {underscore(col.name)} = Column({argstr})'
                    sqla_lines.append(line)
                self.sqla_python_lines += sqla_lines
        # Add comments at top (note most sqla generators do not support comments)
        for tn,t in schema_metadata.tables.items():
            cls = self.table_to_class[tn]
            if t.comment is not None:
                cmt = t.comment.replace("\n","")
            else:
                cmt = ''
            print(f'-- {tn} // {cmt}')
            for c in t.columns:
                if c.comment is not None:
                    cmt = c.comment.replace("\n","")
                else:
                    cmt = ''
                print(f'--   {c} // {cmt}')
        print()
        schema_metadata.create_all(engine)

    def visit_class(self, cls: ClassDefinition) -> bool:
        if self._is_hidden(cls):
            return False
        if cls.description:
            None ## TODO
        tname = self._cls_name(cls.name)
        self.columns[tname] = {}
        return True

    def end_class(self, cls: ClassDefinition) -> None:
        tname = self._cls_name(cls.name)
        if self.use_inherits and cls.is_a:
            # postgresql supports inheritance
            # if you want to use plain SQL DDL then use sqlutils to unfold hierarchy
            # TODO: raise error if the target is standard SQL
            p = self._cls_name(cls.is_a)
            logging.error("Not supported in sqlalchemy")
        self.table_to_class[tname] = cls


    def visit_class_slot(self, cls: ClassDefinition, aliased_slot_name: str, slot: SlotDefinition) -> None:
        #qual = 'repeated ' if slot.multivalued else 'optional ' if not slot.required or slot.key else ''
        slotname = self._slot_name(aliased_slot_name)
        tname = self._cls_name(cls.name)
        slot_range = self.get_sql_range(slot)
        if slot.multivalued:
            linktable_name = f'{tname}_to_{slotname}'
            pk = self._get_primary_key(cls)
            if pk is None:
                if self.inject_primary_keys:
                    pk = 'id'
                    self.columns[tname][pk] = Column(pk, Text(), primary_key=True)
                else:
                    raise Exception(f'Cannot have multivalued on cols with no PK: {tname} . {slotname}')
            ref = f'ref_{tname}'
            linkrange = None
            if isinstance(slot_range, ForeignKey):
                linkrange = Text()
            else:
                linkrange = slot_range
            linktable_slot = slotname
            if slot.singular_name is not None:
                linktable_slot = self._slot_name(slot.singular_name)
            self.columns[linktable_name] = {
                linktable_slot: Column(linktable_slot, linkrange, nullable=False),
                ref: Column(ref, ForeignKey(f'{tname}.{pk}'), nullable=False)
            }
        is_pk = slot.identifier
        if isinstance(slot_range, ForeignKey) and not self.use_foreign_keys:
            slot_range = Text()
        col = Column(slotname, slot_range, primary_key=is_pk, nullable=not slot.required)
        if slot.description:
            col.comment = slot.description
        self.columns[tname][slotname] = col
        self.table_columns_to_slot[(tname, slotname)] = slot

    def get_sql_range(self, slot: SlotDefinition) -> str:

        range = slot.range
        if range in self.schema.classes:
            rc = self.schema.classes[range]
            pk = None
            for sn in rc.slots:
                s = self.schema.slots[sn]
                if s.identifier:
                    if pk is not None:
                        logging.error(f"Multiple pks for {range}: {pk} AND {s}")
                    pk = s.alias if s.alias is not None else s.name
            if pk is not None:
                if self._is_hidden(rc):
                    logging.error(f"Creating non-FK ref for {slot.name} {pk}")
                    return Text()
                else:
                    return ForeignKey(f'{self._slot_name(range)}.{pk}')
        if range in self.schema.types:
            range = self.schema.types[range].base

        if range in self.schema.enums:
            e = self.schema.enums[range]
            if e.permissible_values is not None:
                vs = [str(v) for v in e.permissible_values]
                return Enum(*vs)
        if range in RANGEMAP:
            return RANGEMAP[range]
        else:
            logging.warning(f'UNKNOWN: {range} // {type(range)}')
            return Text()

    def _get_primary_key(self, cls: ClassDefinition) -> SlotDefinition:
        pk = None
        for sn in cls.slots:
            s = self.schema.slots[sn]
            if s.identifier:
                if pk is not None:
                    logging.error(f"Multiple pks for {range}: {pk} AND {s}")
                pk = s.alias if s.alias is not None else s.name
        return pk

@shared_arguments(SQLDDLGenerator)
@click.command()
@click.option("--dialect", default='sqlite', help="""
SQL-Alchemy dialect, e.g. sqlite, mysql+odbc
""")
@click.option("--sqla-file",  help="""
Path to sqlalchemy generated python
""")
@click.option("--use-foreign-keys/--no-use-foreign-keys", default=True, help="Emit FK declarations")
def cli(yamlfile, sqla_file:str = None, **args):
    """ Generate SQL DDL representation """
    gen = SQLDDLGenerator(yamlfile, **args)
    print(gen.serialize(**args))
    if sqla_file is not None:
        with open(sqla_file, "w") as stream:
            stream.write(gen.to_sqla_python())

if __name__ == '__main__':
    cli()
