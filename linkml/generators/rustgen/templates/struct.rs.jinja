mod {{ name }}Slots {
{% for property in properties %}
    {% if property.type_ | length > 1 and property.has_slot_usage %}
    pub enum {{ property.name }}_range {
    {% for t in property.type_ %}
        {{ t }}({{ t }}){% if not loop.last %}, {% endif %}

    {% endfor %}
    
    }
    {% endif %}
{% endfor %}
}

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "pyo3", pyclass(subclass, get_all, set_all))]
pub struct {{ name }} {
{% for property in properties %}
{% filter indent(width=4, first=True, blank=False) %}
{{ property }}
{%- if not loop.last -%},{{ '\n' }}{% else %}{{ '\n' }}{%- endif -%}
{% endfilter %}
{% endfor %}
}

{% if properties | length > 0 %}

#[cfg(feature = "pyo3")]
#[pymethods]
impl {{ name }} {
    #[new]
    pub fn new({% for property in properties %}{{ property.name }}: {{ property.rustrange }}{% if not loop.last %},{% endif %}{% endfor %}) -> Self {
        {{ name }}{ {% for p in property_names %}{{ p }}{% if not loop.last %},{% endif %}{% endfor %} }
    }
}

#[cfg(feature = "pyo3")]
impl<'py> IntoPyObject<'py> for Box<{{ name }}>
{
    type Target = PyAny;
    type Output = Bound<'py, Self::Target>;
    type Error = PyErr;
    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {
        (*self).into_pyobject(py).map(move |x| x.into_any())
    }
}

#[cfg(feature = "pyo3")]
impl<'py> FromPyObject<'py> for Box<{{ name }}> {
    fn extract_bound(ob: &pyo3::Bound<'py, pyo3::types::PyAny>) -> pyo3::PyResult<Self> {
        if let Ok(val) = ob.extract::<{{ name }}>() {
            return Ok(Box::new(val));
        }
        Err(PyErr::new::<pyo3::exceptions::PyTypeError, _>(
            "invalid {{ name}}",
        ))
    }
}



{% endif %}


{% if as_key_value %}
{{ as_key_value }}
{% endif %}