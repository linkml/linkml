#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum {{ name }} {
{% for i in items %}
    {{ i }},
{% endfor %}
}

impl core::fmt::Display for {{ name }} {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
        {% for i in items %}
            {{ name }}::{{ i }} => f.write_str("{{ i }}"),
        {% endfor %}
        }
    }
}

#[cfg(feature = "pyo3")]
impl<'py> IntoPyObject<'py> for {{ name }} {
    type Target = PyAny;
    type Output = Bound<'py, Self::Target>;
    type Error = PyErr;
    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {
        let s: &str = match self {
        {% for i in items %}
            {{ name }}::{{ i }} => "{{ i }}",
        {% endfor %}
        };
        Ok(pyo3::types::PyString::new(py, s).into_any())
    }
}

#[cfg(feature = "pyo3")]
impl<'py> FromPyObject<'py> for {{ name }} {
    fn extract_bound(ob: &pyo3::Bound<'py, pyo3::types::PyAny>) -> pyo3::PyResult<Self> {
        if let Ok(s) = ob.extract::<&str>() {
            match s {
            {% for i in items %}
                "{{ i }}" => Ok({{ name }}::{{ i }}),
            {% endfor %}
                _ => Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(
                    format!("invalid value for {{ name }}: {}", s),
                )),
            }
        } else {
            Err(PyErr::new::<pyo3::exceptions::PyTypeError, _>(
                concat!("expected str for ", stringify!({{ name }})),
            ))
        }
    }
}
