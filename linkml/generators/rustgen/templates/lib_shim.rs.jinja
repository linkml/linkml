//! This file will only be autogenerated once, so it is safe to manually edit (unlike the other generated files)
//! If you want to re-generate it, just delete it and rerun rust generator.

pub mod generated;

pub use generated::*;
pub use chrono::NaiveDate;
pub use chrono::NaiveDateTime;

{% if root_struct_name %}
#[cfg(feature = "serde")]
/// Example helper that loads a YAML document into the root class. Edit or extend as needed.
pub fn load_yaml_{{ root_struct_fn_snake }}<P>(
    path: P,
) -> Result<generated::{{ root_struct_name }}, Box<dyn std::error::Error + Send + Sync>>
where
    P: AsRef<std::path::Path>,
{
    let file = std::fs::File::open(path)?;
    let reader = std::io::BufReader::new(file);
    let parsed = serde_yml::from_reader(reader)?;
    Ok(parsed)
}

#[cfg(all(feature = "pyo3", feature = "serde"))]
#[pyfunction(name = "load_yaml_{{ root_struct_fn_snake }}")]
fn load_yaml_{{ root_struct_fn_snake }}_py(path: &str) -> PyResult<generated::{{ root_struct_name }}> {
    load_yaml_{{ root_struct_fn_snake }}(path)
        .map_err(|err| PyErr::new::<pyo3::exceptions::PyIOError, _>(err.to_string()))
}
{% endif %}

{% if pyo3 %}
#[cfg(feature = "pyo3")]
use pyo3::prelude::*;
#[cfg(all(feature = "pyo3", feature = "serde"))]
use pyo3::wrap_pyfunction;

#[cfg(feature = "pyo3")]
#[pymodule]
#[pyo3(name="{{ module_name }}")]
fn {{ module_name }}(m: &Bound<'_, PyModule>) -> PyResult<()> {
    generated::register_pymodule(m)?;
    {% if root_struct_name %}
    #[cfg(all(feature = "serde", feature = "pyo3"))]
    {
        m.add_function(wrap_pyfunction!(load_yaml_{{ root_struct_fn_snake }}_py, m)?)?;
    }
    {% endif %}
    Ok(())
}
{% endif %}
