use serde::{Deserialize, Deserializer};
use std::collections::{BTreeMap, HashMap};

pub trait InlinedPair: Sized {
    type Key: std::hash::Hash + Eq + serde::de::DeserializeOwned + Clone + Ord;
    type Value: serde::de::DeserializeOwned;

    fn from_pair(k: Self::Key, v: Self::Value) -> Self;
}

pub fn deserialize_inlined_dict_list<'de, D, T>(de: D) -> Result<Vec<T>, D::Error>
where
    D: Deserializer<'de>,
    T: InlinedPair,
{
    let raw: BTreeMap<T::Key, T::Value> = BTreeMap::deserialize(de)?;

    Ok(raw.into_iter().map(|(k, v)| T::from_pair(k, v)).collect())
}

/// Parses `{ k: v, â€¦ }` and returns `HashMap<k, T>`
pub fn deserialize_inlined_dict_map<'de, D, T>(
    de: D,
) -> Result<HashMap<T::Key, T>, D::Error>
where
    D: Deserializer<'de>,
    T: InlinedPair,
{
    let raw: HashMap<T::Key, T::Value> = HashMap::deserialize(de)?;

    Ok(raw
        .into_iter()
        .map(|(k, v)| {
            let obj = T::from_pair(k.clone(), v);
            (k, obj)
        })
        .collect())
}