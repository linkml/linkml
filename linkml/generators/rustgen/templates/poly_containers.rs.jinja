use std::{
    hash::Hash,
    collections::HashMap,
    iter::{Map, IntoIterator},
    ops::{Index, IndexMut},
    slice,
};

/* ------------------------------------------------------------------- *
 *  Immutable view
 * ------------------------------------------------------------------- */

pub struct ListView<'a, T> {
    inner: &'a [Box<T>],
}

impl<'a, T> ListView<'a, T> {
    pub fn len(&self) -> usize        { self.inner.len() }
    pub fn is_empty(&self) -> bool    { self.inner.is_empty() }

    pub fn get(&self, i: usize) -> Option<&T> {
        self.inner.get(i).map(|b| &**b)
    }

    pub fn new(inner: &'a [Box<T>]) -> ListView<'a, T> {
        Self { inner : inner }
    }


    pub fn iter(&self) -> impl Iterator<Item = &T> + '_ {
        self.inner.iter().map(debox)
    }
}

/* Index (`view[i]`) */
impl<'a, T> Index<usize> for ListView<'a, T> {
    type Output = T;
    fn index(&self, i: usize) -> &Self::Output { &*self.inner[i] }
}

/* &ListView iteration  (`for x in &view`) */
type Iter<'a, T> = Map<slice::Iter<'a, Box<T>>, fn(&'a Box<T>) -> &'a T>;
fn debox<'a, T>(b: &'a Box<T>) -> &'a T { &**b }

impl<'a, T> IntoIterator for &'a ListView<'a, T> {
    type Item     = &'a T;
    type IntoIter = Iter<'a, T>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter().map(debox) }
}

/* ------------------------------------------------------------------- *
 *  Mutable view
 * ------------------------------------------------------------------- */

pub struct ListViewMut<'a, T> {
    inner: &'a mut Vec<Box<T>>,
}

impl<'a, T> ListViewMut<'a, T> {
    pub fn len(&self) -> usize        { self.inner.len() }
    pub fn is_empty(&self) -> bool    { self.inner.is_empty() }

    pub fn new(inner: &'a mut Vec<Box<T>>) -> ListViewMut<'a, T> {
        Self { inner : inner }
    }

    pub fn get(&self, i: usize) -> Option<&T> {
        self.inner.get(i).map(|b| &**b)
    }
    pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {
        self.inner.get_mut(i).map(|b| &mut **b)
    }

    pub fn push(&mut self, v: T) {
        self.inner.push(Box::new(v));
    }

    pub fn iter(&self) -> Iter<'_, T> {
        self.inner.iter().map(debox)
    }
    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        self.inner.iter_mut().map(debox_mut)
    }
}

/* Index / IndexMut */
impl<'a, T> Index<usize> for ListViewMut<'a, T> {
    type Output = T;
    fn index(&self, i: usize) -> &Self::Output { &*self.inner[i] }
}
impl<'a, T> IndexMut<usize> for ListViewMut<'a, T> {
    fn index_mut(&mut self, i: usize) -> &mut Self::Output { &mut *self.inner[i] }
}

/* &mut ListViewMut iteration (`for x in &mut view`) */
fn debox_mut<'a, T>(b: &'a mut Box<T>) -> &'a mut T { &mut **b }
type IterMut<'a, T> = Map<slice::IterMut<'a, Box<T>>, fn(&'a mut Box<T>) -> &'a mut T>;

impl<'a, T> IntoIterator for &'a ListViewMut<'a, T> {
    type Item     = &'a T;
    type IntoIter = Iter<'a, T>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter().map(debox) }
}
impl<'a, T> IntoIterator for &'a mut ListViewMut<'a, T> {
    type Item     = &'a mut T;
    type IntoIter = IterMut<'a, T>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter_mut().map(debox_mut) }
}


pub struct MapView<'a, K, V> {
    inner: &'a HashMap<K, Box<V>>,
}

impl<'a, K: Eq + Hash, V> MapView<'a, K, V> {
    /* basic info */
    pub fn len(&self) -> usize        { self.inner.len() }
    pub fn is_empty(&self) -> bool    { self.inner.is_empty() }

    /* look-ups */
    pub fn get(&self, k: &K) -> Option<&V> {
        self.inner.get(k).map(debox)
    }

    pub fn new(inner: &'a HashMap<K, Box<V>>)  -> Self {
        Self { inner : inner }
    }

    pub fn iter(&self) -> impl Iterator<Item = (&K, &V)> + '_ {
        self.inner.iter().map(as_pair)
    }

}

/* &MapView iteration */
type MapIter<'a, K, V> =
    Map<std::collections::hash_map::Iter<'a, K, Box<V>>, fn((&'a K,&'a Box<V>)) -> (&'a K,&'a V)>;

fn as_pair<'a, K, V>((k, v): (&'a K, &'a Box<V>)) -> (&'a K, &'a V) { (k, &**v) }

impl<'a, K: Eq + Hash, V> IntoIterator for &'a MapView<'a, K, V> {
    type Item     = (&'a K, &'a V);
    type IntoIter = MapIter<'a, K, V>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter().map(as_pair) }
}

/* ─────────────────────────────── mutable view ────────────────────── */
pub struct MapViewMut<'a, K, V> {
    inner: &'a mut HashMap<K, Box<V>>,
}

impl<'a, K: Eq + Hash, V> MapViewMut<'a, K, V> {
    /* same basic info */
    pub fn len(&self) -> usize        { self.inner.len() }
    pub fn is_empty(&self) -> bool    { self.inner.is_empty() }

    /* look-ups */
    pub fn get(&self,  k: &K) -> Option<&V>       { self.inner.get(k).map(debox) }
    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> { self.inner.get_mut(k).map(debox_mut) }

    /* insertion / removal */
    pub fn insert(&mut self, k: K, v: V) -> Option<V> {
        self.inner.insert(k, Box::new(v)).map(|old| *old)
    }
    pub fn remove(&mut self, k: &K) -> Option<V> {
        self.inner.remove(k).map(|b| *b)
    }

    /* iterators */
    pub fn iter<'b>(&'b self) -> MapIter<'b, K, V> {
        self.inner.iter().map(as_pair)
    }
    pub fn iter_mut<'b>(&'b mut self) -> MapIterMut<'b, K, V> {
        self.inner.iter_mut().map(as_pair_mut)
    }
}

/* &mut MapViewMut iteration */
type MapIterMut<'a, K, V> =
    Map<std::collections::hash_map::IterMut<'a, K, Box<V>>,
        fn((&'a K,&'a mut Box<V>)) -> (&'a K,&'a mut V)>;

fn as_pair_mut<'a, K, V>((k, v): (&'a K, &'a mut Box<V>)) -> (&'a K, &'a mut V) { (k, &mut **v) }

impl<'a, K: Eq + Hash, V> IntoIterator for &'a mut MapViewMut<'a, K, V> {
    type Item     = (&'a K, &'a mut V);
    type IntoIter = MapIterMut<'a, K, V>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter_mut().map(as_pair_mut) }
}
/* also allow &MapViewMut to iterate immutably */
impl<'a, K: Eq + Hash, V> IntoIterator for &'a MapViewMut<'a, K, V> {
    type Item     = (&'a K, &'a V);
    type IntoIter = MapIter<'a, K, V>;
    fn into_iter(self) -> Self::IntoIter { self.inner.iter().map(as_pair) }
}


pub trait MapRef<K, V> {
    fn get(&self, k: &K) -> Option<&V>;
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool { self.len() == 0 }

    type Iter<'a>: Iterator<Item = (&'a K, &'a V)>
    where
        Self: 'a,
        K: 'a,
        V: 'a;

    fn iter(&self) -> Self::Iter<'_>;
}


/* ---- impl for the real HashMap ---------------------------------- */
impl<K: std::hash::Hash + Eq, V> MapRef<K, V> for std::collections::HashMap<K, V> {
    fn get(&self, k: &K) -> Option<&V> { self.get(k) }
    fn len(&self) -> usize { self.len() }

    type Iter<'a> = std::collections::hash_map::Iter<'a, K, V> where K: 'a, V: 'a;
    fn iter(&self) -> Self::Iter<'_> { self.iter() }
}


/* NEW — borrowed map */
impl<'a, K: Eq + Hash, V> MapRef<K, V> for &'a HashMap<K, V> {
    fn get(&self, k: &K) -> Option<&V> { (*self).get(k) }
    fn len(&self) -> usize             { (*self).len() }

    type Iter<'b> = std::collections::hash_map::Iter<'b, K, V>
    where
        Self: 'b,
        K: 'b,
        V: 'b;

    fn iter(&self) -> Self::Iter<'_> {
        (*self).iter()
    }
}

/* ---- impl for your borrowing MapView ---------------------------- */
impl<'a, K: std::hash::Hash + Eq, V> MapRef<K, V> for MapView<'a, K, V> {
    fn get(&self, k: &K) -> Option<&V> { self.inner.get(k).map(|b| &**b) }
    fn len(&self) -> usize { self.inner.len() }

    type Iter<'b> =
        std::iter::Map<
            std::collections::hash_map::Iter<'b, K, Box<V>>,
            fn((&'b K,&'b Box<V>)) -> (&'b K,&'b V)
        > where K: 'b, V: 'b, Self: 'b;

    fn iter(&self) -> Self::Iter<'_> {
        fn as_pair<'b, K, V>((k, v): (&'b K, &'b Box<V>)) -> (&'b K, &'b V) { (k, &**v) }
        self.inner.iter().map(as_pair)
    }
}



pub trait SeqRef<T> {
    /// Immutable iterator (`for x in seq.iter()`)
    type Iter<'a>: Iterator<Item = &'a T> + ExactSizeIterator
    where
        Self: 'a,
        T: 'a;

    /// Number of elements
    fn len(&self) -> usize;

    /// Immutable indexing
    fn get(&self, i: usize) -> Option<&T>;

    /// Borrowing iterator
    fn iter(&self) -> Self::Iter<'_>;

    /// Convenience
    fn is_empty(&self) -> bool { self.len() == 0 }
}


impl<T> SeqRef<T> for Vec<T> {
    type Iter<'a> = slice::Iter<'a, T> where T: 'a;

    fn len(&self) -> usize              { Vec::len(self) }
    fn get(&self, i: usize) -> Option<&T> { self.as_slice().get(i) }
    fn iter(&self) -> Self::Iter<'_>    { self.as_slice().iter() }
}

impl<T> SeqRef<T> for &Vec<T> {
    type Iter<'a> = slice::Iter<'a, T> where T: 'a, Self: 'a;

    fn len(&self) -> usize              { Vec::len(self) }
    fn get(&self, i: usize) -> Option<&T> { self.as_slice().get(i) }
    fn iter(&self) -> Self::Iter<'_>    { self.as_slice().iter() }
}


impl<'a, T> SeqRef<T> for ListView<'a, T> {
    type Iter<'b> = Iter<'b, T> where Self: 'b, T: 'b;

    fn len(&self) -> usize              { self.inner.len() }
    fn get(&self, i: usize) -> Option<&T> { self.inner.get(i).map(debox) }
    fn iter(&self) -> Self::Iter<'_>    { self.inner.iter().map(debox) }
}
